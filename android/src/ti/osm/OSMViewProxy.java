/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2017 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 */
package ti.osm;

import android.app.Activity;
import android.os.Message;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.AsyncResult;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.titanium.TiC;
import org.appcelerator.titanium.proxy.TiViewProxy;
import org.appcelerator.titanium.util.TiConvert;
import org.appcelerator.titanium.view.TiUIView;

import java.util.ArrayList;
import java.util.HashMap;

@Kroll.proxy(creatableInModule = TiOsmModule.class)
public class OSMViewProxy extends TiViewProxy {
    // Standard Debugging variables
    private static final String LCAT = "ExampleProxy";
    private static final boolean DBG = TiConfig.LOGD;
    public int mapType = 0;
    public boolean userLocation = false;
    public boolean followLocation = false;
    public String userAgent;
    private boolean allowRotation = false;
    private HashMap<String, Object> startLocation;
    private final ArrayList<HashMap> markerList = new ArrayList<HashMap>();

    // Constructor
    public OSMViewProxy() {
        super();
    }

    @Override
    public TiUIView createView(Activity activity) {
        OSMView view = new OSMView(this);
        view.getLayoutParams().autoFillsHeight = true;
        view.getLayoutParams().autoFillsWidth = true;

        if (startLocation != null
                && (!startLocation.containsKey(TiC.PROPERTY_LATITUDE)
                || !startLocation.containsKey(TiC.PROPERTY_LONGITUDE))) {
            Log.e(LCAT, "Unable to set location. Missing latitude or longitude.");
        } else {
            view.setLocation(startLocation);
        }

        if (allowRotation) {
            view.allowRotation(true);
        }

        for (int i = 0; i < markerList.size(); i++) {
            view.addMarker(markerList.get(i));
        }
        try {
            view.updateMarker();
        } catch (Exception e) {
        }
        return view;
    }

    protected OSMView getView() {
        return (OSMView) getOrCreateView();
    }

    // Handle creation options
    @Override
    public void handleCreationDict(KrollDict options) {
        super.handleCreationDict(options);

        if (options.containsKey(TiC.PROPERTY_LOCATION)) {
            setLocation(options.get(TiC.PROPERTY_LOCATION));
        }
        if (options.containsKey(TiC.PROPERTY_MAP_TYPE)) {
            mapType = TiConvert.toInt(options.get(TiC.PROPERTY_MAP_TYPE), 0);
        }
        if (options.containsKey(TiC.PROPERTY_USER_LOCATION)) {
            userLocation = TiConvert.toBoolean(options.get(TiC.PROPERTY_USER_LOCATION));
        }
        if (options.containsKey("followLocation")) {
            followLocation = TiConvert.toBoolean(options.get("followLocation"));
        }
        if (options.containsKey(TiC.PROPERTY_USER_AGENT)) {
            userAgent = TiConvert.toString(options.get(TiC.PROPERTY_USER_AGENT));
        }
    }

    @Kroll.getProperty
    @Kroll.method
    public boolean getAllowRotation() {
        return allowRotation;
    }

    @Kroll.setProperty
    @Kroll.method
    public void setAllowRotation(boolean value) {
        allowRotation = value;
        getView().allowRotation(value);
    }

    @Kroll.getProperty
    @Kroll.method
    public int getMapType() {
        return mapType;
    }

    @Kroll.setProperty
    @Kroll.method
    public void setMapType(int type) {
        mapType = type;
        getView().setMapType(type);
    }

    @Kroll.getProperty
    @Kroll.method
    public KrollDict getLocation() {
        return getView().getLocation();
    }

    @Kroll.setProperty
    @Kroll.method
    public void setLocation(Object location) {
        if (location instanceof HashMap) {
            startLocation = (HashMap<String, Object>) location;
        }

        if (location instanceof HashMap) {
            if (!startLocation.containsKey(TiC.PROPERTY_LATITUDE)
                    || !startLocation.containsKey(TiC.PROPERTY_LONGITUDE)) {
                Log.e(LCAT, "Unable to set location. Missing latitude or longitude.");
                return;
            }
            getView().setLocation(startLocation);
        }
    }

    @Override
    public boolean handleMessage(Message msg) {
        AsyncResult result = null;
        switch (msg.what) {
            case 1: {
                result = (AsyncResult) msg.obj;
                doClearMarker();
                result.setResult(null);
                return true;
            }
        }
        return false;
    }

    // Methods
    @Kroll.method
    public void addMarker(HashMap marker) {
        getView().addMarker(marker);
    }

    @Kroll.method
    public void addMarkers(Object markers) {
        getView().addMarkers(markers);
    }

    @Kroll.method
    public void clearMarker() {
        doClearMarker();
    }

    @Kroll.method
    public void pause() {
        getView().pause();
    }

    @Kroll.method
    public void resume() {
        getView().resume();
    }

    @Kroll.method
    public long cacheCapacity() {
        return getView().cacheCapacity();
    }

    @Kroll.method
    public long currentCacheUsage() {
        return getView().currentCacheUsage();
    }

    @Kroll.method
    public int possibleTilesInArea(int zoommin, int zoommax) {
        return getView().possibleTilesInArea(zoommin, zoommax);
    }

    @Kroll.method
    public void downloadAreaAsync(int zoommin, int zoommax) {
        getView().downloadAreaAsync(zoommin, zoommax);
    }

    @Kroll.getProperty
    public boolean downloadAllowed() {
        return getView().downloadAllowed();
    }

    private void doClearMarker() {
        getView().clearMarker();
    }

    void updateEvent(String event, KrollDict data) {
        if (hasListeners(event)) {
            fireSyncEvent(event, data);
        }
    }

    @Override
    public void onPause(Activity activity) {
        super.onPause(activity);
        getView().pause();
    }

    @Override
    public void onResume(Activity activity) {
        super.onResume(activity);
        getView().resume();
    }
}
